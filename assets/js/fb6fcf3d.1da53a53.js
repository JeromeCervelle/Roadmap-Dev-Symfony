"use strict";(self.webpackChunkroadmap_symfony=self.webpackChunkroadmap_symfony||[]).push([[500],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return m}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),c=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return r.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(t),m=a,f=d["".concat(l,".").concat(m)]||d[m]||p[m]||o;return t?r.createElement(f,i(i({ref:n},u),{},{components:t})):r.createElement(f,i({ref:n},u))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},4858:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return d}});var r=t(7462),a=t(3366),o=(t(7294),t(3905)),i=["components"],s={sidebar_position:8},l="La gestion de l'asynchrone",c={unversionedId:"JavaScript/la gestion-asynchrone",id:"JavaScript/la gestion-asynchrone",isDocsHomePage:!1,title:"La gestion de l'asynchrone",description:"Tous les exemples que l'on a vu jusqu'\xe0 pr\xe9sent fonctionnaient de mani\xe8re synchrone, c'est \xe0 dire qu'il \xe9taient ex\xe9cut\xe9s \xe0 la suite les uns des autres. En JavaScript, on peut aussi faire de l'asynchrone, \xe0 savoir \xe9crire du code qui sera ex\xe9cut\xe9 plus tard.",source:"@site/docs/07-JavaScript/09-la gestion-asynchrone.md",sourceDirName:"07-JavaScript",slug:"/JavaScript/la gestion-asynchrone",permalink:"/Roadmap-Dev-Symfony/docs/JavaScript/la gestion-asynchrone",editUrl:"https://github.com/yoanbernabeu/Roadmap-Dev-Symfony/edit/main/docs/07-JavaScript/09-la gestion-asynchrone.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"La gestion des erreurs",permalink:"/Roadmap-Dev-Symfony/docs/JavaScript/les-erreurs"},next:{title:"La gestion du DOM",permalink:"/Roadmap-Dev-Symfony/docs/JavaScript/DOM"}},u=[{value:"Callback",id:"callback",children:[],level:4},{value:"Promesses",id:"promesses",children:[],level:4},{value:"Ressources",id:"ressources",children:[],level:2}],p={toc:u};function d(e){var n=e.components,t=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"la-gestion-de-lasynchrone"},"La gestion de l'asynchrone"),(0,o.kt)("p",null,"Tous les exemples que l'on a vu jusqu'\xe0 pr\xe9sent fonctionnaient de mani\xe8re synchrone, c'est \xe0 dire qu'il \xe9taient ex\xe9cut\xe9s \xe0 la suite les uns des autres. En JavaScript, on peut aussi faire de l'asynchrone, \xe0 savoir \xe9crire du code qui sera ex\xe9cut\xe9 plus tard."),(0,o.kt)("p",null,"Il existe pour cela deux m\xe9thodes : les callback et les promesses. "),(0,o.kt)("h4",{id:"callback"},"Callback"),(0,o.kt)("p",null,"Les callback consistent en l'\xe9criture d'une fonction qui prend elle m\xeame une fonction de retour, qui sera ex\xe9cut\xe9e quand on le souhaite. "),(0,o.kt)("p",null,"Imaginons que l'on souhaite ex\xe9cut\xe9 une fonction qui attendrait 2 secondes puis retournerait un message. On pourrait \xe9crire les choses comme suit : "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"const wait = (duration, cb) => {\n    setTimeOut(() => {\n        cb()\n    }, duration)\n}\n\nconsole.log('d\xe9part')\n\nwait(2000, () => {\n    console.log('termin\xe9')\n})\n\nconsole.log('attente')\n")),(0,o.kt)("p",null,"Ce code va d'abord \xe9crire ",(0,o.kt)("inlineCode",{parentName:"p"},"d\xe9part"),", puis ",(0,o.kt)("inlineCode",{parentName:"p"},"attente")," et ",(0,o.kt)("inlineCode",{parentName:"p"},"termin\xe9")," au bout de deux secondes."),(0,o.kt)("p",null,"Mais si on doit g\xe9rer plusieurs callback imbriqu\xe9s, on va tomber dans ce qu'on appelle le callbak hell."),(0,o.kt)("h4",{id:"promesses"},"Promesses"),(0,o.kt)("p",null,"Les promesses sont une autre fa\xe7on de g\xe9rer le code asynchrone. Elle s'\xe9crivent de la fa\xe7on suivante :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"const wait = (duration) => {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => resolve(duration), duration)\n    })\n}\n")),(0,o.kt)("p",null,"Ici, la fonction ",(0,o.kt)("inlineCode",{parentName:"p"},"wait")," retourne une promesse, qui prend en param\xe8tre deux callback. ",(0,o.kt)("inlineCode",{parentName:"p"},"resolve")," sera appel\xe9 en cas de succ\xe8s et ",(0,o.kt)("inlineCode",{parentName:"p"},"reject")," en cas d'\xe9chec. On pourra alors apeller la fonction ",(0,o.kt)("inlineCode",{parentName:"p"},"wait")," comme suit : "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"wait(2000)\n    .then((duration) => {\n        console.log(`j'ai attendu ${duration}ms`)\n    })\n    .catch(() => {\n        console.log(`la promesse a \xe9t\xe9 rejet\xe9e`)\n    })\n")),(0,o.kt)("p",null,"L'avantage sur les callback est que si on renvoie une nouvelle promesse dans un ",(0,o.kt)("inlineCode",{parentName:"p"},"then")," on peut alors enchainer les m\xe9thodes."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"wait(2000)\n    .then((duration) => {\n        console.log(`j'ai attendu ${duration}ms`)\n        return wait(3000)\n    })\n    .then((duration) => {\n        console.log(`j'ai attendu ${duration}ms`)\n    })\n")),(0,o.kt)("p",null,"On peut aussi \xe9crire les choses plus simplement avec les mots-clef ",(0,o.kt)("inlineCode",{parentName:"p"},"async")," et ",(0,o.kt)("inlineCode",{parentName:"p"},"await"),". On d\xe9clarre une fonction comme asynchrone avec le mot-clef ",(0,o.kt)("inlineCode",{parentName:"p"},"async"),". Dans ce cas l\xe0, son retour sera une promesse. L'avantage, c'est qu'\xe0 l'interieur de cette fonction, on peut appeller une fonction qui retourne une promesse avec le mot cl\xe9 ",(0,o.kt)("inlineCode",{parentName:"p"},"await"),". Le code qui suit attendra la r\xe9solution de la promesse pour \xeatre ex\xe9cut\xe9."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"const wait = (duration) => {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => resolve(duration), duration)\n    })\n}\n\nconst main = async () => {\n    console.log('d\xe9part')\n    await wait(2000)\n    console.log('fin')\n}\n\nmain()\n")),(0,o.kt)("p",null,"Ce code va d'abord \xe9crire ",(0,o.kt)("inlineCode",{parentName:"p"},"d\xe9part"),", puis ",(0,o.kt)("inlineCode",{parentName:"p"},"termin\xe9")," au bout de deux secondes."),(0,o.kt)("h2",{id:"ressources"},"Ressources"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://grafikart.fr/tutoriels/javascript-promise-2067#autoplay"},"Apprendre \xe0 g\xe9rer les promesses par Grafikart"))))}d.isMDXComponent=!0}}]);